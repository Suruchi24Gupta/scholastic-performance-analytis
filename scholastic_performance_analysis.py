# -*- coding: utf-8 -*-
"""Scholastic_Performance_Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iSgNvqgbMGOpVxlGB0fgdqodAfYyhDPM
"""

!pip install numpy
!pip install pandas
!pip install matplotlib
!pip install seaborn

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("Student_Performance.csv")  #df=dataframe
print(df.head()) #printing the 1st 5 rows of the data

df.describe() # describes all the numberic values in the data

df.info() #tells the columns data type(which we can change)

df.isnull().sum()

"""#Delete Unnamed Column"""

df = df.drop("Unnamed: 0", axis = 1)
print(df.head())

"""#Change Weekly Study Hours"""

df["WklyStudyHours"] = df["WklyStudyHours"].str.replace("05-Oct","5-10")
df.head()

"""#**Gender distribution**"""

sns.countplot(data = df, x = "Gender")
plt.title("Gender Distribution")
plt.show()

plt.figure(figsize = (5,5))
ax = sns.countplot(data = df, x = "Gender")
ax.bar_label(ax.containers[0])
plt.title("Gender Distribution")
plt.show()

"""#*No. of females is more than the males*

1) plt.figure(figsize=(5, 5)): This line creates a new figure for the plot with a specified figure size of 5 inches in width and 5 inches in height. It sets up the canvas on which the countplot will be drawn, controlling its dimensions.

2) ax = sns.countplot(data=df, x="Gender"): This line creates a countplot using Seaborn's countplot function. It takes two main arguments:

a)data=df: This specifies the DataFrame (df) from which the data for the plot will be drawn.
x="Gender": This specifies the variable from the DataFrame (df) that will be used on the x-axis of the countplot. In this case, it's the "Gender" column from the DataFrame.
The resulting ax object is an Axes object representing the countplot, and it's used for further customization of the plot.

b)ax.bar_label(ax.containers[0]): This line adds labels to the bars in the countplot. Here's what each part does:

3) ax.containers[0]: ax.containers is a list of the individual bar containers in the countplot. The [0] index refers to the first (and in this case, the only) container in the list.

4) ax.bar_label(...): This function adds labels to the bars in the specified container. In this case, it adds labels to the bars in the countplot.

5)plt.show(): This line displays the plot on the screen. It's necessary to show the plot after all customization has been applied to visualize the result.
"""

gb = df.groupby("ParentEduc").agg({"MathScore":'mean',"ReadingScore":'mean', "WritingScore":'mean' })
print(gb)

sns.heatmap(gb)
plt.show()

plt.figure(figsize=(4,5))
sns.heatmap(gb, annot=True)
plt.title("Impact on students performance due to their Parents education")
plt.show()

"""When creating a heatmap using **sns.heatmap **, setting **annot=True** will display the numeric values in each cell of the heatmap.
It is particularly **useful when you want to visualize the actual data values along with the color representation in the heatmap**, which can** help in data interpretation.**

**Here, through this heatmap, it is recognised that the students marks are getting impacted due to their parent's education.**
"""

gb1 = df.groupby("ParentMaritalStatus").agg({"MathScore":'mean',"ReadingScore":'mean', "WritingScore":'mean' })
print(gb1)

plt.title("Impact on student's performance due to their Parents marital status")
sns.heatmap(gb1, annot = True)
plt.figure(figsize=(4,5))
print(gb1)

sns.boxplot(data=df, x="MathScore")
plt.show()

"""Ther are so many outlier present in this boxplot.
**Boxplot tells us whether our data consist of outliers or not!**
Means there is **one min** and **one max value** which **denotes the range** and **25%le** of data lies at the **starting** of the blue box and** 75%** of data lies at the **end** of the blue box, and **the rest lies outside **the plot which are the **outliers.**

**Here, in the outlier there is 1 student who scores the min marks in the Maths subject.**
"""

sns.boxplot(data=df, x="ReadingScore")
plt.show()

"""**Here, in the outlier there are 3 students who scores the min marks in the Reading.**


"""

sns.boxplot(data=df, x="WritingScore")
plt.show()

"""**On the basis of these 3 boxplots for the 3 subject, it gives result that Maths is the poorer subject for the students to score.**"""

print(df["EthnicGroup"].unique())

"""The code **print(df["EthnicGroup"].unique())** is used to print the unique values present in the "EthnicGroup" column of a DataFrame called df.

**df["EthnicGroup"]**: This part of the code accesses the "EthnicGroup" column within the DataFrame df. It's essentially extracting all the values from that specific column.

**.unique():** The unique() method is called on the values extracted from the "EthnicGroup" column. This method is used to identify and return the unique (distinct) values within an array, in this case, the unique values in the "EthnicGroup" column.

#**Distribution of Ethnic Groups**
"""

groupA = df.loc[(df['EthnicGroup'] == "group A")].count()
print(groupA)

groupB = df.loc[(df['EthnicGroup'] == "group B")].count()
print(groupB)

groupC = df.loc[(df['EthnicGroup'] == "group C")].count()
print(groupC)

groupD = df.loc[(df['EthnicGroup'] == "group D")].count()
print(groupD)

groupE = df.loc[(df['EthnicGroup'] == "group E")].count()
print(groupE)

l = ["groupA","groupB","groupC","groupD","groupE"]
plist = [groupA["EthnicGroup"], groupB["EthnicGroup"], groupC["EthnicGroup"], groupD["EthnicGroup"], groupE["EthnicGroup"]]

print(plist)
plt.pie(plist, labels = l, autopct = "%1.2f%%")
plt.title("Distribution of Ethnic Groups")
plt.show()

"""**l = ["groupA", "groupB", "groupC", "groupD", "groupE"]:** This line initializes a list l containing the labels for different ethnic groups. These labels will be used later when creating a pie chart to identify each slice of the chart.

**plist = [groupA["EthnicGroup"], groupB["EthnicGroup"], groupC["EthnicGroup"], groupD["EthnicGroup"], groupE["EthnicGroup"]]:** This line creates a list plist containing the counts of individuals in each ethnic group. It appears that groupA, groupB, groupC, groupD, and groupE are variables that store information about each ethnic group, including the count of individuals in each group.

**plt.pie(plist, labels=l, autopct="%1.2f%%"): **This line creates a pie chart using the plist data as the sizes of the pie slices, l as the labels for each slice, and autopct="%1.2f%%" to display the percentage of each slice with two decimal places.
"""

ax = sns.countplot(data = df, x = 'EthnicGroup')
ax.bar_label(ax.containers[0])

"""**ax = sns.countplot(data=df, x='EthnicGroup'):** This line of code uses Seaborn to create a countplot. A countplot is a type of bar plot that displays the count of observations in each category of a categorical variable. Here's what each part does:
ax: This line initializes a variable ax to store the reference to the generated countplot, allowing you to further customize or manipulate the plot.

**sns.countplot(...):** This is the Seaborn function used to create the countplot.
data=df: It specifies the DataFrame (df) from which the data for the plot will be sourced.
x='EthnicGroup': This specifies the variable from the DataFrame (df) that will be plotted on the x-axis of the countplot, which is the "EthnicGroup" column in this case.


**ax.bar_label(ax.containers[0]):** This line adds labels to the bars in the countplot. Here's what each part does:
ax.bar_label(...): This method is called on the ax object (which is the countplot created earlier) to add labels to the bars.
ax.containers[0]: ax.containers is a list of the individual bar containers in the countplot. The [0] index refers to the first (and in this case, the only) container in the list. The ax.containers[0] represents the bars themselves.

So, in summary, the code creates a countplot of the "EthnicGroup" column from the DataFrame df, and then it adds labels to the bars in the countplot to display the exact count of observations for each category of ethnic groups.






"""